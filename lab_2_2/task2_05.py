# 5) Декоратор кэширования

# Напишите декоратор cache, который кэширует результат вызова функции (сохраняет в словаре).
# Когда функция вызывается снова с теми же аргументами,
# декоратор должен возвращать результат из кэша, вместо того, чтобы вызывать декорированную функцию.

def cache(func):
    cached_results = {} # словарь для хранения результатов — ключ: аргументы, значение: результат

    def wrapper(*args):
        if args in cached_results: # если такие аргументы уже были — результат есть в кэше
            print(f"Из кэша: {args} → {cached_results[args]}")  # выводит, что берёт из кэша
            return cached_results[args]   # возвращает сохранённый результат
        result = func(*args) # иначе вызывает оригинальную функцию
        cached_results[args] = result # сохраняет результат в кэш
        print(f"Вычислено: {args} → {result}")
        return result

    return wrapper

@cache # применяет декоратор — теперь slow_add будет кэшироваться
def slow_add(a, b):
    print("Выполняется сложение...")
    return a + b

# Тестирование
print(slow_add(2, 3)) # вычисляется
print(slow_add(2, 3)) # результат берётся из кэша
print(slow_add(4, 5)) # вычисляется
print(slow_add(4, 5)) # берётся из кэша


